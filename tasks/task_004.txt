# Task ID: 4
# Title: Define ESPN API Source in dlt
# Status: pending
# Dependencies: 3
# Priority: high
# Description: Create the dlt source definition for the ESPN API in the dlt_sources module.
# Details:
Create the espn_api_source.py file with the main source definition for ESPN NCAA Men's College Basketball data. The source should include resources for all the entities mentioned in the PRD's Conceptual Data Model section.

This task serves as a parent task for subtasks 4.1 and 4.2, which will handle the specific implementation of the dlt resources. The main goal is to ensure the complete `espn_api_source.py` file is created with all six resources (`seasons`, `season_types`, `weeks`, `events`, `event_competitors`, `teams`) correctly defined and registered.

The source should support optional date-based partitioning and properly handle the relationships between different ESPN API endpoints. Each resource should have appropriate primary keys and write dispositions to ensure data integrity.

# Test Strategy:
Write unit tests that mock API responses and verify that the dlt source correctly extracts and structures the data. Test with sample responses collected during API exploration. Unit tests should cover all resources to ensure they properly handle the API responses and edge cases.

# Subtasks:
## 1. Define `seasons`, `season_types`, and `weeks` dlt Resources [pending]
### Dependencies: None
### Description: Implement the `seasons`, `season_types`, and `weeks` dlt resources within `dlt_sources/espn_api_source.py`.
### Details:
This subtask focuses on creating the initial structure of the `espn_ncaa_basketball_source` function and defining the first three resources (`seasons`, `season_types`, `weeks`) as specified in the original Task 4 details. Ensure these resources interact correctly with the ESPN API endpoints (`/seasons`, `/seasons/{season_id}/types`, `/seasons/{season_id}/types/{type_id}/weeks`) and handle primary keys and write dispositions as outlined in Task 4. The code for these resources can be taken from the Task 4 description. This subtask includes creating `dlt_sources/espn_api_source.py` if it doesn't exist and defining the `espn_ncaa_basketball_source` along with these three initial resources. These three resources should be returned by the main source function for now.
<info added on 2025-05-07T16:07:22.939Z>
This subtask focuses on creating the initial structure of the `espn_ncaa_basketball_source` function in `dlt_sources/espn_api_source.py` and defining the first three resources (`seasons`, `season_types`, `weeks`).

Create `dlt_sources/espn_api_source.py` with the following content:

```python
import dlt
import requests
from typing import Dict, List, Optional, Any

@dlt.source
def espn_ncaa_basketball_source(partition_date: Optional[str] = None):
    """Source for ESPN NCAA Men's College Basketball data.
    
    Args:
        partition_date: Optional date string in YYYY-MM-DD format for partitioned loads
    """
    base_url = dlt.config.value(name="base_url") # This will be set via env: SOURCES__ESPN_NCAA_BASKETBALL_SOURCE__BASE_URL
    
    @dlt.resource(
        primary_key=["id"],
        write_disposition="merge"
    )
    def seasons():
        """Fetch available seasons"""
        # Endpoint: /seasons (documented in API inventory)
        # This endpoint returns a list of $ref links. For simplicity in this initial step,
        # we are assuming it returns the season data directly as per the original PRD snippet.
        # Actual handling of $ref might be more complex and involve yielding URLs for another resource.
        response = requests.get(f"{base_url}/seasons")
        response.raise_for_status()
        # The actual API returns {'items': [{'$ref': '...'}, ...]}, so we'd typically yield these $refs
        # or fetch them. For now, assuming direct data as per original example for this subtask.
        # This simplification might need refinement later if the API strictly adheres to $ref for list items.
        return response.json().get("items", []) # Adjusted based on typical API list structure

    @dlt.resource(
        primary_key=["id", "season_id"],
        write_disposition="merge"
    )
    def season_types(season_id: str): # This resource would typically depend on `seasons` yielding season_ids
        """Fetch season types for a specific season"""
        # Endpoint: /seasons/{season_id}/types
        # Similar to seasons, this often returns $ref links.
        response = requests.get(f"{base_url}/seasons/{season_id}/types")
        response.raise_for_status()
        # Assuming direct data for now.
        types_data = response.json().get("items", [])
        # Add season_id to each type for composite key and context
        for type_info in types_data:
            type_info['season_id'] = season_id
        return types_data


    @dlt.resource(
        primary_key=["id", "season_id", "season_type_id"], # Assuming 'id' from type_info is season_type_id
        write_disposition="merge"
    )
    def weeks(season_id: str, season_type_id: str): # Depends on `season_types`
        """Fetch weeks for a specific season and type"""
        # Endpoint: /seasons/{season_id}/types/{season_type_id}/weeks
        response = requests.get(f"{base_url}/seasons/{season_id}/types/{season_type_id}/weeks")
        response.raise_for_status()
        weeks_data = response.json().get("items", [])
        # Add parent IDs for composite key and context
        for week_info in weeks_data:
            week_info['season_id'] = season_id
            week_info['season_type_id'] = season_type_id
        return weeks_data

    return {
        "seasons": seasons,
        "season_types": season_types,
        "weeks": weeks
    }
```

Ensure these resources handle primary keys and write dispositions as shown. Note the comments about potential `$ref` handling for `seasons` and `season_types` which are simplified for this initial step based on the original PRD snippet but might need adjustments based on exact API behavior explored in Task 3. The `base_url` is fetched from `dlt.config.value`.
</info added on 2025-05-07T16:07:22.939Z>

## 2. Define `events`, `event_competitors`, and `teams` dlt Resources [pending]
### Dependencies: None
### Description: Implement the `events`, `event_competitors`, and `teams` dlt resources within `dlt_sources/espn_api_source.py`.
### Details:
This subtask focuses on adding the `events`, `event_competitors`, and `teams` resources to the `espn_ncaa_basketball_source` function in `dlt_sources/espn_api_source.py`. These resources should interact with `/scoreboard` and `/teams` endpoints, handling primary keys and write dispositions as outlined in Task 4. The `event_competitors` resource will likely extract data from the `events` resource's output. The code for these resources can be taken from the Task 4 description. After implementing these, ensure all six resources (from 4.1 and 4.2) are correctly registered in the dictionary returned by the main `espn_ncaa_basketball_source` function.
<info added on 2025-05-07T16:07:52.763Z>
This subtask focuses on adding the `events`, `event_competitors`, and `teams` resources to the `espn_ncaa_basketball_source` function in `dlt_sources/espn_api_source.py` (which was created and initially populated in subtask 4.1).

Add the following resource definitions to the `espn_ncaa_basketball_source` function:

```python
# (existing code from 4.1: imports, source decorator, seasons, season_types, weeks resources)
# ...

    @dlt.resource(
        primary_key=["id"],
        write_disposition="merge"
    )
    def events(date: Optional[str] = None):
        """Fetch events/games, optionally filtered by date or the source's partition_date"""
        # Endpoint: /scoreboard?dates=YYYYMMDD
        url = f"{base_url}/scoreboard"
        params = {}
        # Use the specific date if provided to the resource, else use the source-level partition_date
        effective_date = date if date else partition_date
        if effective_date:
            params["dates"] = effective_date.replace("-", "")
            
        response = requests.get(url, params=params)
        response.raise_for_status()
        data = response.json()
        return data.get("events", [])

    @dlt.resource(
        primary_key=["id", "event_id"],
        write_disposition="merge"
    )
    def event_competitors(event_data: Dict): # Depends on `events` yielding event_data items
        """Extract competitors from event data"""
        competitors = []
        event_id = event_data.get("id") # Get event_id from the event_data itself
        for competition in event_data.get("competitions", []):
             for competitor in competition.get("competitors", []):
                # Add event_id for composite key and context
                # Important: Ensure the 'id' field for the competitor itself is unique *within that event*.
                # dlt will hash the composite primary_key (competitor's id + event_id) for the dlt_id.
                competitor_copy = competitor.copy()
                competitor_copy["event_id"] = event_id
                competitors.append(competitor_copy)
        return competitors

    @dlt.resource(
        primary_key=["id"],
        write_disposition="merge"
    )
    def teams():
        """Fetch team information"""
        # Endpoint: /teams
        # This structure is based on the original PRD snippet. 
        # The actual /teams endpoint might be paginated or structured differently (e.g. sports->leagues->teams)
        # and may require more complex parsing or yielding $ref links to individual team details.
        response = requests.get(f"{base_url}/teams")
        response.raise_for_status()
        # The PRD example was: response.json().get("sports", [{}])[0].get("leagues", [{}])[0].get("teams", [])
        # A more robust way or direct items if the API returns a list of teams:
        data = response.json()
        if isinstance(data.get("items"), list):
             return data.get("items", [])
        elif isinstance(data.get("teams"), list):
             return data.get("teams", [])
        elif isinstance(data.get("sports"), list) and len(data["sports"]) > 0 and \
             isinstance(data["sports"][0].get("leagues"), list) and len(data["sports"][0]["leagues"]) > 0 and \
             isinstance(data["sports"][0]["leagues"][0].get("teams"), list):
             return data["sports"][0]["leagues"][0]["teams"]
        return [] # Fallback to empty list

# ... (end of espn_ncaa_basketball_source function)
```

After adding these, update the `return` statement at the end of the `espn_ncaa_basketball_source` function to include all six resources:

```python
    return {
        "seasons": seasons,
        "season_types": season_types,
        "weeks": weeks,
        "events": events,
        "event_competitors": event_competitors,
        "teams": teams
    }
```

Ensure these resources handle primary keys, write dispositions, and dependencies (e.g., `event_competitors` processing output from `events`) as shown. Note the comments about potential API structure nuances for `teams`.
</info added on 2025-05-07T16:07:52.763Z>

